场景： 曝光埋点

解决方案： 利用js 类 IntersectionObserver 观察目标元素， 目标元素出现在窗口内出发埋点

- 一般会设置一个时间间隔，先收集对象ID， 到时间后统一遍历触发
- 利用单例原则，定义一个曝光埋点的class, 将实例挂载到window

注意事项：

- 单例子原则
- 不要重复上报

```javascript
class Exposure {
  constructor(maxNum=19){
    this.dotDataArr = [] // 收集的将要上报的数据
    this.maxNum = maxNum // 一次上报最大的数量
    this._observer=null //  观察者
    this.observedDom=[] // 存储已经上报的dom
    this.init()
  }
  init(){
    const _self = this
    try{
      this._observer = new IntersectionObserver((entries)={
        // 遍历被观察元素判断是否进入视图
        entries.map((entry)=>{
        	const {isIntersecting, target} = entry
          if(isIntersecting){
            // 从被观察元素中获取属性进行埋点
            const {attributes} = target
            const eventId = attributes["data-eventid"].value
            const eventParams = attributes["date-dot"].value //jsonstring
            add({eventId, eventParams})
            // 解除观察
           self._observer.unobserve(target)
          }
      })
      }, {
        root: document.querySelector('#app'),
        rootMargin: "0px";
        threshold: 1 //  目标dom 出现在试图的比例 0-1
      })
    }catch(){
      console.log("浏览器不支持IntersectionObserver")
    }
  }
  // 添加监控对象
  add(entry){
    //  判断是否已经被观察，已经被观察，什么都不用做，没有被观察开启观察，存储到被观察队列 
    const {el} = entry
    // 获取元素id
    const {attributes} = el
    const id = attributes[id].value
    // 判断ID是否已经在被观察队列
    if(this.observeddom.includes(id)){
      return
    }
    // 开启观察保存ID
    this._observer && this._observer.observe(el)
    this.observeddom.push(id)
  } 
  // 埋点方法
  dot(params){
    const {eventId, eventParams} = params
    window.JSSDK && Window.JSSDK.sendPont({eventId, eventParams})
  }
  // clear
  clear(){
    this.observedDom = []
  }
  
  // 离开页面前上报埋点
  beforeUnmount(){
    
  }
}
```

